{"meta":{"title":"Xiangxin","subtitle":null,"description":null,"author":"刘相鑫","url":"http://lxyzk.github.io"},"pages":[],"posts":[{"title":"URLProtocol导致上传进度回调丢失排查过程","slug":"ns-url-protocol","date":"2020-01-02T05:04:34.000Z","updated":"2020-03-28T14:14:38.838Z","comments":true,"path":"2020/01/02/ns-url-protocol/","link":"","permalink":"http://lxyzk.github.io/2020/01/02/ns-url-protocol/","excerpt":"问题发现最近开发时候发现了一个奇怪的问题，在使用iOS的NSURLSessionManager进行文件上传时候，回调方法 12345- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend; 无论如何也不会被调用。","text":"问题发现最近开发时候发现了一个奇怪的问题，在使用iOS的NSURLSessionManager进行文件上传时候，回调方法 12345- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend; 无论如何也不会被调用。 问题排查尝试了各种[NSURLSession uploadTaskWithRequest]的写法都已失败告终。 百思不得其解，为了确定是不是NSURLSession自身的bug自己写了一个Demo App尝试了一下，竟然可以正常回调。 于是感觉可能是在某处HOOK了NSURLSession的API导致的问题，于是赶紧在工程里面搜索一下NSURLSeesion的各个类相关的方法，还是没有找到。 就在问题即将要变得难搞的时候，偶然在控制台的日志里面看到有输出我发送的请求的信息，立刻就意识到可能是某个URLProtocol拦截了我发送的请求，于是用URLProtocol做关键字在工程里面搜，果然，公司的网络性能监控框架通过注册了自己的URLProtocol来拦截请求信息，记录请求的性能问题。 于是先注释掉监控用的URLProtocol注册的代码，再尝试一下，果然能正常收到回调了。看来问题就是出现在这里。 翻看了一下监控URLProtocol的代码，看起来用的也没有问题。于是只好去搜索下看看有没有其他的解决方案。 解决问题找到了苹果的一个示例说明文档 里面有一段： Similarly, there is no way for your NSURLProtocol subclass to call the NSURLConnection delegate’s -connection:needNewBodyStream: or -connection:didSendBodyData:totalBytesWritten:totalBytesExpectedToWrite: methods (rdar://problem/9226155 and rdar://problem/9226157). The latter is not a serious concern–it just means that your clients don’t get upload progress–but the former is a real issue. If you’re in a situation where you might need a second copy of a request body, you will need your own logic to make that copy, including the case where the body is a stream. 大意是说我们自己实例化的NSURLProtocol子类没有办法调用client的-connection:didSendBodyData:totalBytesWritten:totalBytesExpectedToWrite:方法，所以没有办法把进度通知到client，也就不会调用上面的- (void)URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法。要解决这个问题就要自己去copy请求的body。 性能监控的NSURLProtocol的逻辑暂时没有办法更改，那没有办法，只有在上传的时候禁止监控了。 性能监控的PerformanceURLProtocol的canInitWithRequest里面有这么一段代码： 12345+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; if ([NSURLProtocol propertyForKey:@\"PerformanceHTTPHandledIdentifier\" inRequest:request] ) &#123; return NO; &#125;&#125; 根据这段代码，在上传文件之前先调用一下 1234Class HMDURLProtocol = NSClassFromString(@\"PerformanceURLProtocol\");if ([PerformanceURLProtocol isSubclassOfClass:NSURLProtocol.class]) &#123; [PerformanceURLProtocol setProperty:@YES forKey:@\"PerformanceHTTPHandledIdentifier\" inRequest:request];&#125; 防止进入PerformanceURLProtocol的拦截逻辑。 重新运行代码， 一切正常。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://lxyzk.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://lxyzk.github.io/tags/iOS/"},{"name":"NSURLProtol","slug":"NSURLProtol","permalink":"http://lxyzk.github.io/tags/NSURLProtol/"},{"name":"upload","slug":"upload","permalink":"http://lxyzk.github.io/tags/upload/"},{"name":"network","slug":"network","permalink":"http://lxyzk.github.io/tags/network/"}]},{"title":"使用Xcode10调试iOS13设备","slug":"debug-new-device-on-old-xcode","date":"2019-08-11T12:51:41.000Z","updated":"2020-03-28T14:14:38.837Z","comments":true,"path":"2019/08/11/debug-new-device-on-old-xcode/","link":"","permalink":"http://lxyzk.github.io/2019/08/11/debug-new-device-on-old-xcode/","excerpt":"在iOS13适配过程中会有使用低版本的SDK进行编译然后跑在高版本的设备上进行兼容性适配。 如果每次都打包出来跑在高版本的设备上实在有些麻烦又不方便Debug。其实，低版本的Xcode是可以调试高版本的设备的，只是需要进行一点改动。","text":"在iOS13适配过程中会有使用低版本的SDK进行编译然后跑在高版本的设备上进行兼容性适配。 如果每次都打包出来跑在高版本的设备上实在有些麻烦又不方便Debug。其实，低版本的Xcode是可以调试高版本的设备的，只是需要进行一点改动。 低版本Xcode调试高版本真机Xcode的真机部署和调试依赖一个叫做 Device Support File的东西， 每个版本的固件都有对应的该文件，只有电脑的device Support File和目标设备的系统匹配才可以调试。 对应新版本固件的Device Support File都是随新版本的Xcode附带， 首先下载好新版本的Xcode(目前最新版的是Xcode 11 beta)，然后到(假设新版本的Xcode是Xcode-beta)1/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 复制对应版本的Device Support File, 注意：要整个目录一起复制， 比如上图就是复制整个13.0目录 到旧版本的目录1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 输入密码， 重启下旧版Xcode就可以调试高版本真机了。 低版本Xcode调试高版本模拟器要调试高版本的模拟器， 只需要先下载一个高版本的Xcode，然后随便打开一个项目运行一下， 等模拟器启动起来。 然后再旧版本的Xcode上就可以选择高版本的模拟器进行调试了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://lxyzk.github.io/categories/iOS/"}],"tags":[{"name":"xcode","slug":"xcode","permalink":"http://lxyzk.github.io/tags/xcode/"},{"name":"ios","slug":"ios","permalink":"http://lxyzk.github.io/tags/ios/"}]},{"title":"Debian源码安装Vim","slug":"compile_vim_debian","date":"2019-05-28T13:55:14.000Z","updated":"2020-03-28T14:14:38.837Z","comments":true,"path":"2019/05/28/compile_vim_debian/","link":"","permalink":"http://lxyzk.github.io/2019/05/28/compile_vim_debian/","excerpt":"由于想使用SpaceVim的一套配置， 但很多Vim的插件需要启用+lua或+python配置， 服务器上自带的没有这些配置，所以从源码来自行编译Vim启用这些配置。","text":"由于想使用SpaceVim的一套配置， 但很多Vim的插件需要启用+lua或+python配置， 服务器上自带的没有这些配置，所以从源码来自行编译Vim启用这些配置。 卸载原有的vim12sudo apt-get remove --purge vim vim-runtime vim-gnome vim-tiny vim-gui-commonsudo rm -rf /usr/local/share/vim /usr/bin/vim 下载源码包1git clone https://github.com/vim/vim 安装依赖123456sudo apt-get install lua5.1 liblua5.1-dev \\ luajit libluajit-5.1 \\ python-dev python3-dev ruby-dev \\ libperl-dev libncurses5-dev \\ libatk1.0-dev libx11-dev \\ libxpm-dev libxt-dev 编译Vim配置123456789101112./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --enable-pythoninterp=yes \\ --with-python-config-dir=/usr/lib/python2.7/config \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr/lib/python3.5/config \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-gui=gtk2 \\ --enable-cscope \\ --prefix=/usr/local 这里要注意：--with-python-config-dir 和 --with-python3-config-dir 两项， 要选择正确的config目录 编译1sudo make install 设置为默认编辑器1234sudo update-alternatives --install /usr/bin/editor editor /usr/local/bin/vim 1sudo update-alternatives --set editor /usr/local/bin/vimsudo update-alternatives --install /usr/bin/vi vi /usr/local/bin/vim 1sudo update-alternatives --set vi /usr/local/bin/vim 确认1vim --version","categories":[{"name":"Vim","slug":"Vim","permalink":"http://lxyzk.github.io/categories/Vim/"}],"tags":[{"name":"Debian","slug":"Debian","permalink":"http://lxyzk.github.io/tags/Debian/"},{"name":"Vim","slug":"Vim","permalink":"http://lxyzk.github.io/tags/Vim/"},{"name":"+lua","slug":"lua","permalink":"http://lxyzk.github.io/tags/lua/"}]},{"title":"在树莓派上配置下载机","slug":"raspberry-pi-aria","date":"2018-08-25T14:16:14.000Z","updated":"2020-03-28T14:14:38.838Z","comments":true,"path":"2018/08/25/raspberry-pi-aria/","link":"","permalink":"http://lxyzk.github.io/2018/08/25/raspberry-pi-aria/","excerpt":"最近看美剧，为了专心\b享受美剧的快乐避免烦人的下载保存， 想到了把手头的一个树莓派和一个移动硬盘配置成下载机。 这样，客厅的小米盒子就\b可以通过局域网直接播放下载完的视频。","text":"最近看美剧，为了专心\b享受美剧的快乐避免烦人的下载保存， 想到了把手头的一个树莓派和一个移动硬盘配置成下载机。 这样，客厅的小米盒子就\b可以通过局域网直接播放下载完的视频。 硬件准备 把移动硬盘插到树莓派上, 在\b树莓派中是/dev/sda1 通过网线将树莓派连接到\b路由器上 在路由器的DHCP配置中将树莓派的IP配置为固定IP:192.168.31.121 安装Docker在shell\b中执行 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 配置存储目录建立下载目录1234cd ~mkdir nascd nas mkdir part0 挂载移动硬盘在/etc/fstable中添加下面的一行 1/dev/sda1 /home/pi/nas/part0/ ext4 defaults 0 2 在shell中执行 1mount -a \b\b配置\bAria2安装镜像建立配置文件目录 12cd ~mkdir aria2-conf \b启动镜像 12345docker run -d --name aria2-ariang-pi \\-p 6800:6800 -p 80:80 -p 8080:8080 \\-v /home/pi/nas/part0:/aria2/downloads \\-v /home/pi/aria2-conf:/aria2/conf \\-e SECRET=123 huangzulin/aria2-ariang-pi #RPC\b服务认证密码 \b执行完毕后，\b在浏览器输入 http://192.168.31.121 访问Aria-Ng的前端页面 http://192.168.31.121:8080 访问文件管理 如果提示连接错误，到AriaNg Setting - RPC选项卡中将Aria2 RPC Secret Token设置为上面的123 配置SMB服务器1234567891011sudo docker run -it -p 139:139 -p 445:445 \\ -p 137:137/udp \\ -p 138:138/udp \\ -v /home/pi/nas/part0:/downloads \\ -d --name=&quot;samba&quot; dperson/samba:rpi \\ -u &quot;pi;pi&quot; \\ #用户名:密码 -s &quot;downloads;/downloads;yes;no;no;all;pi&quot; # 显示名\b称;\b映射路径,跟 第四行后面的/downloads对应 -g &quot;extensions = no&quot; \\ -n \\ -W \\ -S 执行完后可以通过smb://192.168.31.121 访问文件服务， \b并且客厅的小米盒子\b也可以\b发现并访问","categories":[{"name":"折腾","slug":"折腾","permalink":"http://lxyzk.github.io/categories/折腾/"}],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://lxyzk.github.io/tags/Raspberry/"},{"name":"Aria2","slug":"Aria2","permalink":"http://lxyzk.github.io/tags/Aria2/"},{"name":"Docker","slug":"Docker","permalink":"http://lxyzk.github.io/tags/Docker/"}]},{"title":"TCP/IP 笔记","slug":"tcp-ip-note","date":"2018-04-17T07:02:07.000Z","updated":"2020-03-28T14:14:38.838Z","comments":true,"path":"2018/04/17/tcp-ip-note/","link":"","permalink":"http://lxyzk.github.io/2018/04/17/tcp-ip-note/","excerpt":"最近又重温了TCP/IP的知识，果然比第一次看的时候有感悟多了，那就写一点东西来总结一下。","text":"最近又重温了TCP/IP的知识，果然比第一次看的时候有感悟多了，那就写一点东西来总结一下。 网络模型现在我们主要了解计算机网络的两种模型：OSI模型和TCP/IP模型。需要注意的是由于OSI模型过于复杂导致难以实现，因此导致TCP/IP模型更早地应用在现实中。这也使得TCP/IP模型成为事实上的标准，而OSI仅仅是纸面上的标准。 在OSI模型中，将计算机网络分成了7层，而在TCP/IP模型中则分成了4层，其各层对应关系如下表所示： OSI TCP/IP 对应网络协议 所在位置 应用层 应用层 TFTP, FTP, NFS, WAIS 主机 表示层 Telnet, Rlogin, SNMP, Gopher 会话层 SMTP, DNS 传输层 传输层 TCP, UDP 网络层 网际层 IP, ICMP, ARP, RARP, AKP, UUCP 媒介 数据链路层 网络接口层 FDDI, Ethernet, Arpanet, PDN, SLIP, PPP 物理层 IEEE 802.1A, IEEE 802.2到IEEE 802.11 UDP与TCP协议在整个计算机网络体系中，最核心的当属是位于传输层的TCP与UDP协议了。因为他们位于主机协议栈的最底层，向上方应用层提供不同的数据交付方式。 因为UDP协议相对TCP协议来说相对简单，就先回顾一下UDP协议。 UDP协议特点UDP的全称也叫做用户数据报协议（User Datagram Protocal），它有以下几个值得注意的特点： UDP不能保证可靠传输，也就更不能保证所发送的数据的到达顺序，它所实现的是尽最大的努力交付。 UDP是面向数据报文的、无连接的协议，因此它的开销低并且发送器前的时延小（因为不用建立连接啊），面向报文也使得IP层在传输UDP协议的报文时既不会拆分也不会合并。 UDP可以支持一对一、一对多、多对一、多对多的通信。 UDP没有拥塞控制功能，它的发送速率不会随着网络出现的拥塞而降低，所以它的实时性较好。这也是许多视频聊天应用采用它的原因。 报文格式如下是UDP报文头部格式 其中从1到8字节分别是来源端口号、目的端口号、报文长度、检验和，每个字段各占两字节。 UDP的通信方式较为简单，发送端发送完一个报文继续发送下一个，待将所有报文发送完毕通信就结束了。 接收方也是如此。 TCP协议传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP协议所要实现的功能是端到端之间的可靠传输，因此，相较于UDP协议而言，TCP协议要复杂的多。 特点相对于UDP协议，TCP协议有下面的几个特点： TCP协议保证可靠传输，也就是说发送的数据是什么样，接收的数据也是什么样。 TCP协议是有连接的、面向数据流的协议。有连接是说数据传送前通信双方需要建立连接、通信完毕后需要断开连接，不过这里所提到的连接都是逻辑上的连接。面向数据流的意思是说发送方应用程序发送的数据是什么顺序，接收方应用读取的接收到的数据也是什么顺序。 TCP协议提供的是端到端的通信，也就是说一条TCP连接只能提供一对一的通信。不过，一个应用可以同时建立多条TCP连接来实现与多个目标的通信。 TCP协议提供拥塞控制功能，会在网络状况良好的情况下适当提高发送/接收速率，反之则适当降低发送/接收速率。这样，将会提高对网络的利用率。 此外，还需要注意的是，TCP提供的是全双工的通信。 数据封包格式要理解TCP协议中各功能的实现，要先从TCP的数据封包结构开始。 下面的图片就是TCP数据封包的结构示意图： 各个字段功能如下： 来源端口（2字节）：标识来源端口号。 目的端口（2字节）：标识目的端口号。 序列号码（4字节）：表明此封包在字节流中的顺序号。因为TCP是面向字节流的协议，需要保证最终的数据顺序与发送方发送的顺序一致，所以需要这个字段来表明该封包在字节流中的位置。 确认号码（4字节）：对此前按顺序收到的最后一个封包的序列号码的确认。例如：当33号以前的封包都已经完整的到达了后，就向发送方发送确认号码为34（确认的封包号码+1）来告诉发送方：33号以前的所有封包我都已经收到了，可以向我发送34号封包了。这里要注意： 如果收到了34、35、37号封包而未收到36号封包，则向发送端发送确认号为35的封包。 总之要记住，确认号=N，表示N-1及其之前的封包都已经收到。 报头长度（1字节）：指示报文头部的长度。但是需要注意，这里的单位是4字节。例如，这个属性的值是15的话则说明报文头部的长度是60(15*4)字节。 保留字段(10位)：暂时没打算好干啥用，一律置0。 标识符（6位）：每个比特位分别表示如下标识符：URG—为1表示高优先级数据包，紧急指针字段有效。ACK—为1表示确认号字段有效。TCP规定连接建立后，所有传送的报文段都必须把该字段置为1。PSH—为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。RST—为1表示出现严重差错。可能需要重现创建TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求。SYN—为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步FIN—为1表示发送方没有数据要传输了，要求释放连接。 窗口（2字节）:表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。用于流量控制。 校验和（2字节）对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。这是一个强制性的字段。 紧急指针（2字节）：本报文段中的紧急数据的最后一个字节的序号。 选项字段（最多40字节）：每个选项的开始是1字节的kind字段，说明选项的类型。 其中上面的3、4、7、8是重点。 超时重传为了搞明白下面要说的TCP的一些机制，首先需要知道TCP协议能够实现可靠传输的一个基本的原理–超时重传。 说来很简单，其实就是收到当接收方收到一个数据封包的时候就向发送方发送一个确认数据封包。而当发送方发送完一个数据封包经过一段时间没有收到接收方的确认封包时，就会将上一个封包再次向接收方发送一次。 当然，TCP中真正的机制比这个要复杂的多，但是基于的原理都是一样的。 TCP连接管理在说TCP连接之前先插播一个小故事。 说是有一天，一个程序员到酒吧去喝酒，于是跟服务员之间发生了如下的对话。程序员：我要一瓶酒。服务员：你确定你要一瓶酒？程序员：我确定我要一瓶酒。于是服务员就给了程序员一瓶酒。 是不是很罗嗦？没错，这就是典型的TCP连接建立的过程。如下面的图： 图中的小人就是客户端，另一边不用说也知道就是服务器端。图中画的比较简略，大概过程是下面这样： 下面过程中，ACK表示上面说的TCP包头中的确认标识，ack表示确认号(4字节那个)。 客户端向服务器发送建立连接请求数据包，其中包头内容SYN=1，seq=x（自己随机挑选的起始序号）。（我要一瓶酒） 服务器收到请求后，如果同意建立连接，就向客户端发送同意建立连接请求数据封包，其包头内容SYN=1,ACK=1,ack=x+1(还记得为什么吗),seq=y（同样也是自己随机挑选的）。（你确定你要一瓶酒吗） 客户端收到服务器发来的确认请求后，也向服务器发送确认封包，其内容ACK=1，ack=y+1(原理同上),seq=x+1（毕竟已经发送过seq=x的封包了），随后客户端就进入连接建立状态，而服务器就在收到这个确认封包后也进入连接建立状态。（我确定我要一瓶酒） 以上步骤就是俗称的“TCP三次握手”。 当然，最初的时候服务器肯定是处于监听状态啦，要不然怎么能够对客户端的数据封包做出回应呢。 要注意的是，这里有个很经典的问题就是为什么在收到服务器的确认封包后还要再向服务器发送一个确认封包呢？ 这主要是因为TCP协议的下层网络是不可靠的，也就是说数据封包可能丢失也可能滞留在某个节点很长时间。 所以这就有一种可能就是客户端发送给服务器的封包在网络中滞留了，这样客户端当然也就不会收到服务器发来的确认封包。还记得TCP有个超时重传机制吗？没错，这个时候客户端是以为自己发出去的封包在网络中是丢了的，于是过一段时间又会重传刚才的封包。 幸运的是，这次重传的封包十分顺利的到达了服务器，于是服务器也十分顺利的向客户端发出了确认封包。本来就要愉快的建立连接了，可是天有不测风云，刚才滞留的请求封包此时到达了服务器这里。 这个时候服务器就懵了，这到底是客户端又要跟我建立一次连接还是刚才滞留的封包又给了我呢？ 于是这个时候就需要客户端再发送一个确认封包给服务器了。 当然，有连接建立，就有连接释放，客户端与服务器之间的连接释放过程大概是下面这个样子的。 跟建立连接的时候差不多，大概过程大概向下面这样： 客户端向服务器发送连接请求释放封包，封包内容为FIN=1，seq=u。 服务器收到后，决定要跟客户端释放连接，可是还有数据没传送完啊，就先发一个封包告诉客户端我可以释放连接，你可以不用向我发送数据了，可是我还有数据没有传送完，所以在我告诉你结束之前你得一直接收我的数据（别忘了，TCP可是全双工的）。所以所发送封包内容为：ACK=1，ack=u+1,seq=v。（FIN=0表示我还有数据要发送） 服务器发送完数据后，告诉客户端我都发送完了，可以结束了。于是发送封包为FIN=1，ACK=1，ack=u+1(这里得注意啦)，seq=w（中间还传输过数据，所以可能不是v+1）。 客户端收到服务器的确认后，再次向服务器发送确认，内容是ACK=1，ack=w+1，seq=u+1。 发送完上面的确认封包后，客户端再等一段时间（2MSL）后，就断开连接。至此，连接正常释放。 如上步骤就是俗称的“TCP4次挥手”。 这里之所以是4次，主要是与建立连接时相比，服务器的确认和结束被分成了两个封包分别发送了出去。 当然，这里也有个比较经典的问题就是客户端为什么在发送完最后一个封包后还要再等待一段时间？ 这里也主要是因为TCP协议下层的网络并不是很可靠，有可能客户端发出的最后一个封包在路上丢了而导致服务器等待很长世间浪费服务器资源。于是就让客户端再等待一段时间，这样当服务器收不到客户端发来的确认封包时，还会再重传一个连接结束封包，此时的客户端再次受到这个连接结束封包后还可以再重传一次确认封包来让服务器正常结束连接。这样，就不会白白浪费服务器资源了。 一个数据包的旅程最后，再从整个网络的范围来看，一个数据封包到底是要经过怎样的旅程才会从出发地到达目的地呢？ 以TCP协议为例，当TCP协议接到上层应用层交付下来的数据封包后，就在这个数据封包的前面加上TCP的头部。 然后，再交付给下层的网络层。 网络层接收到上层传输层传递下来的封包后，就在封包的头部加上IP协议的头部和网际接口层的首部和头部后经过层层路由，最终到达距离目的主机最近的路由器。 然后距离目的主机最近的路由器再对数据包进行解包，去掉网际接口层和网络层的封装后将数据包送到目的主机的传输层（TCP接收缓冲池），再由目的主机的传输层交给上层的应用层。 一图以蔽之： 参考链接维基百科-TCP/IP协议簇维基百科-用户数据报协议维基百科-传输控制协议","categories":[{"name":"networking","slug":"networking","permalink":"http://lxyzk.github.io/categories/networking/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"http://lxyzk.github.io/tags/tcp-ip/"},{"name":"networking","slug":"networking","permalink":"http://lxyzk.github.io/tags/networking/"}]},{"title":"TCP/IP 拥塞控制","slug":"tcp-ip-congestion-control","date":"2018-04-17T06:54:32.000Z","updated":"2020-03-28T14:14:38.838Z","comments":true,"path":"2018/04/17/tcp-ip-congestion-control/","link":"","permalink":"http://lxyzk.github.io/2018/04/17/tcp-ip-congestion-control/","excerpt":"什么是拥塞我们都知道计算机网络中的资源是有限的。某段时间内网络中对资源的需求超过了网络中的可用部分，而导致网络性能下降的情况就是拥塞。 通俗点说就是发送的数据包太多网络中的设备处理不过来，而导致网络性能下降的情况。","text":"什么是拥塞我们都知道计算机网络中的资源是有限的。某段时间内网络中对资源的需求超过了网络中的可用部分，而导致网络性能下降的情况就是拥塞。 通俗点说就是发送的数据包太多网络中的设备处理不过来，而导致网络性能下降的情况。 TCP为什么要进行拥塞控制网络中的路由器会有一个数据包处理队列，当路由器接收到的数据包太多而一下子处理不过来时，就会导致数据包处理队列过长。此时，路由器就会无条件的丢弃新接收到的数据封包。 这就会导致上层的TCP协议以为数据包在网络中丢失，进而重传这些数据包，而路由器又会丢弃这些重传的数据包，如此以往，就会导致网络性能急剧下降，引起网络瘫痪。 因此，TCP需要控制数据包发送的数量来避免网络性能的下降。 拥塞控制与流量控制的区别引用书上的答案： 拥塞控制就是防止过多的数据注入到网络中，这样可以防止网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 流量控制往往指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 拥塞控制的方法慢开始拥塞窗口拥塞窗口（cwnd）是指发送方维护的一个根据网络状况动态变化的窗口。一般来说，发送方会让自己的发送窗口等于拥塞窗口的大小。 如果考虑到流量控制的话，发送窗口也有可能小于拥塞窗口的大小。 传输轮次一个传输轮次是指发送方把自己的发送窗口内的数据全部发送出去并收到对最后一个字节的确认。 例如，A将自己的发送窗口内的数据全部连续发送给了B，而B收到这些数据后向A发送了对这些数据的确认，A收到这个确认后，一个传输轮次就算是完成了。 慢开始算法慢开始算法中的主要方法就是有小到大逐渐增大发送窗口。 那么，具体是怎么增大的呢？ 简单来说就是每个传输轮次后将cwnd大小加倍。 举个例子： 首先，发送方设置cwnd=1（为方便理解，这里用报文段的个数作为窗口大小的单位），在收到接收方发来的确认后（也就是下个传输轮次），设置cwnd=2，然后将发送窗口的数据发送出去。在一次收到接收方发来的确认后，发送方设置cwnd=4，再讲发送窗口中的数据发送出去。然后再重复上面的过程。 这里就应该清楚，慢开始算法中的慢不是说cwnd增长的慢，而是相对一下子发送大量数据而言，这种一次先发送少量的数据包的方式要慢许多。 当然，cwnd的大小肯定不可能一直以这种指数的方式增长下去，要不然很快就会增长到引起网络瘫痪的程度了。 所以，经过一定时间或条件，我们就要换成拥塞避免算法来发送数据。 拥塞避免慢开始门限 ssthresh像上面所说，不能任由慢开始算法中的cwnd任意增长，所以我们引入一个慢开始门限（ssthresh）的阈值来控制cwnd的增长。 具体作用如下： cwnd &lt; ssthresh ，使用慢开始算法 cwnd = ssthresh , 使用慢开始算法或拥塞避免算法都可以 cwnd &gt; ssthresh , 使用拥塞避免算法呢 还有一个问题就是这个ssthresh是怎么设置的呢？ TCP/IP中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把ssthresh设置为此时发送窗口的一半大小（不能小于2）。 拥塞避免过程拥塞避免算法也是逐渐的增大cwnd的大小，只是采用的是线性增长而不是像慢开始算法那样的指数增长。 具体来说就是每个传输轮次后将cwnd的大小加一（加法增大），如果发现出现网络拥塞的话就按照上面的方法重新设置ssthresh的大小（乘法减小）并从cwnd=1开始重新执行慢开始算法。 如下面的图片所示： （图片来源于网络） 快重传前面复习到过，TCP的可靠传输的原理就是超时重传机制。配合上面的慢开始和拥塞避免使用就是发送发发送完数据后设置一个定时器，如果在定时器时间内没有收到对接收方发来的确认的话就去执行上述的乘法减小过程并重新开始慢开始算法。 而快重传则是允许发送方再连续收到3个重复的确认后就可以开始执行乘法减小过程而不必再等待所设置的重传计时器到时。 这就需要接收方没收到一个失序的报文段就立即发出重复确认以让发送发及早知道有报文段丢失，而不是等待自己发送数据的时候进行捎带确认。 快恢复快恢复算法是与快重传算法配合使用的一个算法。 使用了快恢复算法后与原来不同的一点是当发现网络出现拥塞并执行了乘法减小过程后，并不是设置cwnd=1并重新开始执行慢开始算法，而是让cwnd=乘法减小后的ssthresh并开始执行拥塞避免算法。 因为此时发送发能连续接收到三个重复的确认就可以认为此时网络很可能没有发生拥塞。 使用了快重传和快恢复的拥塞避免过程如下： （图片来源于网络） TCP的发送窗口到底是多大发送窗口的上限值 = Min{rwnd, cwnd} rwnd：接收方接收窗口cwnd：发送方拥塞窗口","categories":[{"name":"networking","slug":"networking","permalink":"http://lxyzk.github.io/categories/networking/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"http://lxyzk.github.io/tags/tcp-ip/"},{"name":"networking","slug":"networking","permalink":"http://lxyzk.github.io/tags/networking/"}]},{"title":"First Post","slug":"first-post","date":"2018-04-16T06:58:30.000Z","updated":"2020-03-28T14:14:38.837Z","comments":true,"path":"2018/04/16/first-post/","link":"","permalink":"http://lxyzk.github.io/2018/04/16/first-post/","excerpt":"","text":"第一篇博客这篇博客的意义是for test 测试二级标题二级标题 test 测试三级标题三级标题test","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-04-16T06:58:30.000Z","updated":"2020-03-28T14:14:38.838Z","comments":true,"path":"2018/04/16/hello-world/","link":"","permalink":"http://lxyzk.github.io/2018/04/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}